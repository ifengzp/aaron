<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小游戏性能优化]]></title>
    <url>%2F2020%2F07%2F02%2F%E6%B8%B8%E6%88%8F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[异名最近负责了一个微信小游戏的项目，在版本迭代间隙对游戏的性能调优进行了一次尝试。这个游戏是个打击类游戏，游戏过程可以查看下图👇 参数指标引擎和小游戏都有一个性能面板，给开发者们暴露了下面几个性能指标： Frame time(ms) 每一帧的时间。《RAIL模型》建议在10毫秒或更短的时间内制作动画中的每一帧。从技术上讲，每帧的最大预算为16毫秒（1000毫秒/每秒60帧≈16毫秒），但是浏览器需要大约6毫秒才能渲染每帧，因此建议每帧10毫秒或者更短。 Framerate(FPS) 帧率，也叫每秒传输帧数(FPS：Frames Per Second)，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数；每秒钟帧数越多，所显示的动作就会越流畅，举个例子电影的帧频是24，也就是说1s需要播放24张图片，但是实际上在游戏过程中一般人能接受的最低FPS约为30Hz。帧率也非越高越好，因为显卡处理能力=分辨率×刷新率，分辨率不变的情况下，帧频越高，GPU处理的数据量也会激增，引起卡顿。同理，分辨率也不是约高越好。在某些终端的性能面板下也会展示这三个相关的参数： rt-fps(runtime fps)：实时帧率； ex-fps：平均帧率； min-fps：最小帧率； Draw call CPU和GPU是并行工作的，它们之间存在一个命令缓冲区。当CPU需要调用图形编程接口的时候就会往命令缓冲区里面增加命令，当GPU完成上一次渲染命令的时候就会继续从命令缓冲区中执行下一条命令，命令缓冲区里面的命令有很多中，而drawcall就是其中的一种。CPU在提交drawcall的时候需要处理很多东西，比如一些数据、状态、命令等等，有些渲染卡顿问题就是因为GPU渲染速度比drawcall的提交速度快，可能上一次渲染完了，CPU还在计算drawcall，所以drawcall的性能瓶颈在于CPU。优化drawcall最有效的方法合批渲染，就是把大量小的drawcall合并成大的drawcall，减少drawcall的数量。 Tris 和 Verts Tris和Verts是渲染的三角面数以及顶点数，在webgl中只有三种基本图元，分别是点、线段和三角形，无论多么复杂的模型本质上都是由这三个基本图元绘制而来的，无论形状多么怪异，它们的本质都是由一个个顶点组成，GPU 将这些点用三角图元绘制成一个个的微小平面，再把这些三角行互相连接，就能绘制出各种复杂的物体了； 一般来说模型的顶点和三角形数越低，模型的复杂度就会越低，所以这两个参数在3D模型中比较有参考意义，设计师在输出3D模型的时候一般都会帮忙去合并一下网格。但是在大部分情况下，我们都会认为性能瓶颈在drawcall上，比如有两种情形，情形一是有1000个物体，每个物体的顶点数是10，情景二是有10个物体，每个物体的顶点数是1000，哪个情景的性能更好？首先我们要明白GPU的渲染速度是非常快的，渲染10个顶点组成的三角图元和1000个顶点组成的三角图元通常没啥区别，所以这两种情形中产生drawcall更少的情形二性能更好。当然如果你在shader里面对顶点做了一些特殊的处理，比如复杂的计算啥的，那就得权衡一下这两个指标的大小影响了 实操降低DrawCall想要减少drawcall就要从影响渲染状态的因素入手，比如纹理图片、纹理的渲染模式、Blend方式等等。但是在大部分项目中其实我们也不会有多大的需求去单独修改引擎的默认渲染参数，如果你动手了，那肯定是会打断合批的 因此在绝大部分情况下，在项目中降低drawcall收益比最大的其实是就是利用引擎提供的静态合图和动态合图的功能。静态合图就是自动图集了，或者使用第三方的图集工具TexturePacker，把资源中的散图进行合并，尽量让画面中的节点都使用一张图集，因为同一张图集的纹理状态都是一致的，所以能够达到渲染批次合并对纹理状态的要求；引擎中的动态合图有两种，一种作用对象是图片资源，是引擎默认启用的，如果不希望使用就在资源面板中把Packable勾掉，或者把全局的合图开关关掉cc.dynamicAtlasManager.enabled = false; ；一种是针对label的，可以在label的cache模式中进行不同的模式切换。下面就介绍一下异名在这个项目中针对drawcall做的一些处理和收益： 合理管理节点画面外的节点可以直接移除，drawcall从50降到了23： 合理设置label的cache模式把首页上三个label的cache模式改为bitmap，首页上的drawcall从79降低到50 有一些频繁更改的label，当cache模式改为char的时候，在我的苹果手机上差别不大，但是在小伙伴的安卓手机上流畅度上升十分明显，ex-fps从500降到了两百以下 合并图集在合并图集的时候需要根据画面的内容去做划分，尽量把同一个画面用的的图片资源打包成一个图集。以游戏中的一个中后关卡为例（前面关卡的画面节点太少，差异不明显），drawcall均值从190降到了90，drawcall峰值从220降到了127。 通过Performance排查问题在开发中的时候，异名会使用Chrome的DevTools，如果是在浏览器中排查性能问题需要屏蔽所有的浏览器插件，最好就是打开隐私模式来调试，因为插件在后台运行会造成干扰。但是在上线前异名会选择使用微信开发者工具的DevTools来再查看一下性能，因为在浏览器的中跑的项目是调试模式，一来没有做合图，而来它也没有经过小游戏的编译，所以为了减少和最终项目效果的偏差，最终会以微信开发者工具中的指标为最终的参考指标。 和手机终端环境相比，我们的电脑的CPU是很快的，为了尽可能模拟用户的终端硬件情况，我们首先需要对CPU做一下节流，例如我现在选中的6x slowdown就会使我们本地CPU的运算速率比正常情况下降6倍。 这时候我们重新去生成录制结果，就可以发现面板上已经出现了醒目的红色告警信息了： Recurring handler聚焦放大然后把轴线定位到每个小的告警信息处，可以在Summary中看到浏览器给出的警告信息，我发现这里面的告警信息都是一样的，都是Recurring handler，而且有规律地出现，可以通过Initiator去查看重复出现的地方以及具体的执行代码： 虽然我们已经看到了代码执行的具体位置是requestAnimateFrame，但是这个api调用不是我们的业务逻辑，而是引擎的封装调用，引擎的帧回调应该是用requestAnimateFrame实现的，也就是说在update的钩子里面可能存在重复调用的逻辑，在这里就需要进一步地去分析了。我们需要根据Main面板中火焰图也就是JS调用栈一步步去寻找并落实到具体的业务代码调用细节，如果能够定位到我们逻辑中的调用函数，马上对症下药就能解决了。但是在异名的这个项目中Recurring handler给到的信息很难定位，task下面调用栈调用的都是引擎自身的渲染方法，当然横向去看调用的先后顺序的话，它在touchMove事件后面运行，这是一个排查方向，需要去分析自己的代码运行调用。如果像异名遇到的这种情况，控制台只能定位到一堆引擎的渲染函数，而不能很明确地定位到我们的具体业务逻辑中，异名会建议放一放，因为重复渲染的问题可能会在long task拆分的过程中被fix掉。 Long task可以通俗理解为一段执行时间很长的js逻辑就是长任务，”长任务”占用着主线程，即使我们的页面看上去准备好了，但是也不能响应用户的操作和点击等交互。至于这个执行时间多长才算是“长”呢？《RAIL模型》建议我们每个任务最好都控制在50毫秒内，Chrome在控制台中也给出了醒目的长任务提示： 大型的脚本是长任务的主要原因，异名这里先举一个在项目中拆分长任务的简单的例子。异名的游戏中有个复活的逻辑，会在碰撞的回调中会处理一下血量和相关的掉血交互，然后当玩家血量耗尽就会唤起一个复活弹窗，这段逻辑就产生了一个long task,耗时55.74ms，火焰图如下： 仔细分析一下，我的碰撞的逻辑处理和唤起复活弹窗虽然是顺序调用，但是它们之间算是一个比较清晰的逻辑界线，而且askResurgence这个函数是一个唤起UI弹窗的函数，既然产生了性能限制，我们就在这里做一个任务拆分：1234// 用setTimeout包裹一下，把它放在下个宏任务执行setTimeout(() =&gt; &#123; this.askResurgence();&#125;) 这时候我们再看拆分后的火焰图，long task标记已经消失了，本来一个长任务，被拆分成了3个任务（中间一个是GC），而且三个任务的耗时相加和开始的长任务相比是折半了的。异名通过排查梳理之后，发现一些很明确的UI状态过渡都很容易造成长任务，异名的项目中还有好几处都是这种界线分明混合逻辑，当你遇到性能压力的时候或许可以像我一样做一下处理。 总结一下拆解大型脚本的时候首先需要把大段的js逻辑重新梳理一遍，可以把一些能提前或者延后的状态拆解到我们应用的空闲阶段去初始化或者变更，比如在首页就先把游戏过程中需要的数据加载进来，游戏过程的的逻辑中就不用再去加载这部分数据了，但是这属于比较“宏观的”逻辑变更，但是大部分情况下我们的状态和逻辑变更都是很难提前或者延后的。我们还可以做一些时间颗粒度更小的逻辑拆分，那就是结合js的事件循环机制来处理我们的逻辑，像用Promise.then或者setTimeout去做一下任务延迟，甚至可以建立一个任务队列去做事件缓存等，这篇《idle-until-urgent》有介绍到一些比较具体的拆解脚本措施。任务拆分是有风险的，无论是在应用的层面去提升或者延后逻辑，还是利用js的微任务或者宏任务去延后状态逻辑，都会有可能导致你的应用状态同步出现问题，所以在实操之后记得好好测试一下整个流程。 长任务还可以通过精简自身的逻辑来优化，像在一些循环中，如果可以做跳出判断自己是否有做；还有在一些地方你写的逻辑是否执行冗余或者无用，比如在异名的项目中这段交互逻辑👇 123456789// 效果甚微的动画交互，干掉this.node.setScale(1.2);const frequency = getRandom(15, 40) / 100;this.centerNode.runAction( cc.sequence( cc.scaleBy(frequency, 1.1), cc.scaleTo(frequency, 1) ).repeatForever()); 它只是一个呼吸变化，在实际的画面效果中，这种小变化其实是很微弱的，可以认为它是一个可有可无的动画逻辑，那我们在做性能优化的时候就需要果断地把它给删除了，把这些冗余的逻辑干掉之后，game logic的数值就已经可以很明确地降低下来了。 其他目前还存在较明显的性能方面：发热、敌人数量增多时容易卡顿 发热是个比较综合的问题，一般来说CPU导致发热，降低CPU的工作会有效减少发热。卡顿则受到帧频和drawcall的影响比较大，通常有以下这些优化手段 降低帧数：目前已动态设置帧频，游戏过程60帧，非游戏过程30帧 减少帧回调：目前update中还有很大的逻辑优化空间 减少内存使用：这块目前也有很大的优化空间，GC回收，节点池，对象和节点复用、缓存等等，甚至包括一些贴图的引用释放等 drawcall优化：其实还可以借助一些帧调试工具去进一步分析，项目的后期应该还会对drawcall优化进行再深入一点的探索，到时候如果有别的收获就再和大家分享]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js求最佳基因配对率]]></title>
    <url>%2F2019%2F01%2F30%2Fjs%E6%B1%82%E6%9C%80%E4%BD%B3%E5%9F%BA%E5%9B%A0%E9%85%8D%E5%AF%B9%E7%8E%87%2F</url>
    <content type="text"><![CDATA[给出一个长度为10的由基因“ATGC”随机组成的参照字符串，然后再给出一个长度为6的可操作基因字符串，可操作字符串的字符顺序不能变，但是可以移动其位置，求移动字符串和参照字符串的最大配对率 题目来源项目中的一个”基因“配对小游戏，如下：按上图中给出的例子： 参考碱基序列为：GGACCCATTC 可顺序移动碱基序列为：TACAGT**** 其中*可移动，匹配率 = 符合配对规则的字母个数 / 总字母个数 当可移动碱基的位置为*TAC**AGT*时有和参考序列有4个碱基匹配，此时匹配率为：4/10，是最优匹配率 全组合为了节省时间，项目中采取了全组合的方法，把所有情况列举出来，然后对比，取匹配率最高的一种情况作为答案。 转换一下就知道，题目等于是有10个位置，任意取四个放空白碱基，一共有C(10,4) = 10!/(4! * 6!) = 10 * 9 * 8 * 7 / (1 * 2 * 3 * 4) = 210种情况，代码如下： 12345678910111213141516171819202122232425262728function toCalculateBestPairingRatio() &#123; const contrastGene = 'GGACCCATTC'.split(''); const gene = 'TACAGT'.split(''); let tempGene, curNum = 0; let bestPairingRate = &#123; rate: 0, arrangement: '' &#125;; for (let i = 0; i &lt; 10; i++) &#123; for (let j = i + 1; j &lt; 10; j++) &#123; for (let k = j + 1; k &lt; 10; k++) &#123; for (let l = k + 1; l &lt; 10; l++) &#123; tempGene = [...gene]; tempGene.splice(i, 0, ''); tempGene.splice(j, 0, ''); tempGene.splice(k, 0, ''); tempGene.splice(l, 0, ''); curNum = contrastGene.reduce((acc, cur, index) =&gt; acc + (cur === tempGene[index]), 0); if (curNum &gt;= bestPairingRate.rate) &#123; bestPairingRate.rate = curNum; bestPairingRate.arrangement = tempGene; &#125; &#125; &#125; &#125; &#125; return bestPairingRate;&#125; 动态规划全组合虽然能够解决本次问题，但是其复杂度为Ο(n!)，当基数再大一点的时候就不适合了。像这种求解最优的问题非常适合使用动态规划，把上题中的基因通过表格列出，行表示参考碱基序列，列表示可顺序移动碱基序列，从第一个碱基开始逐渐增加，表格内为最佳碱基配对率 j\i G G A C C C A T T C T 0 0 0 0 0 0 0 1 1 1 A - 0 1 1 1 1 1 1 1 1 C - - 0 2 2 2 2 2 2 2 A - - - 0 2 2 3 3 3 3 G - - - - 0 2 2 3 3 3 T - - - - - 0 2 3 4 4 Row表示行，i为其下标，Col表示列，j为其下标，Rate表示最佳匹配率，通过观察可以发现规律： Rate[j][i] = Max{Rate[j-1][i-1] + Number(Row[i] == Col[j]), Rate[j][i - 1]}其中当只有一行时Rate[j-1][i-1] = 0，表格左下角则为最大的匹配率 123456789101112function toCalculateBestPairingRatio() &#123; const contrastGene = 'GGACCCATTC'.split(''); const gene = 'TACAGT'.split(''); let arr = [] for (let j = 0; j &lt; gene.length; j++) &#123; arr[j] = [] for (let i = j; i &lt; contrastGene.length; i++ ) &#123; arr[j][i] = Math.max((j == 0 ? 0 : arr[j-1][i-1]) + Number(contrastGene[i] == gene[j]), arr[j][i - 1] || 0) &#125; &#125; return arr[gene.length - 1][contrastGene.length - 1]&#125; 该方法的算法复杂度为平方阶，能够完美解决当前问题，就算后面的基数扩增也不怕了]]></content>
      <tags>
        <tag>算法</tag>
        <tag>全组合</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眼疾手快》项目小结]]></title>
    <url>%2F2019%2F01%2F15%2F%E7%9C%BC%E7%96%BE%E6%89%8B%E5%BF%AB%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[眼疾手快是国庆期间用小程序开发的一个益智小游戏，游戏的玩法是：每一局都从数字1-9中随机抽出一个数字作为答案，然后把剩下的8个数字顺序打乱，随机采取横或者竖或者九宫格的布局展示在页面上，让用户点击输入缺失的数字，要求输入准确而且时间越快越好。 核心算法的实现核心算法就是要从1-9中随机抽出一个数字作为答案，并且打乱剩下八个数字。1234567891011121314151617makeQuestion () &#123; const ansIndex = Math.floor(Math.random() * 9) + 1; let num = '123456789', curNum = '', question = [], answer = ''; for (let k = 9; k &gt; 0; k--) &#123; curNum = num.charAt(Math.floor(Math.random() * k)); num = num.replace(curNum, ''); if (k === ansIndex) &#123; answer = curNum; curNum = ''; &#125; question[k - 1] = curNum &#125; return &#123; question: question, answer: answer &#125;&#125; 图片加载遇到了问题首先这是个很小的教学类游戏，图片资源较少，所有的图片资源都放在本地，当用户下载完小程序包之后都是本地的资源的引用，加上时间紧急我就没有考虑做图片预加载，但是在测试阶段发现还是偶尔有部分图片会长时间没有加载出来，这样问题就有点诡异。 小程序内做图片预加载吧第一想法就是做图片预加载。在web中我们有Image对象，只需要写一个队列，当所有需要预加载的图片都onload完毕之后返回成功状态就可以了，简单实现如下：123456789101112function preloadImg(urls) &#123; if (!Array.isArray(urls)) return Promise.resolve(); const list = urls.map(link =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image(); img.onload = resolve; img.onerror = reject; img.src = link; &#125; &#125;); return Promise.all(list);&#125; 但是小程序里面没有Image对象，那就不能这样实现了，但是虽然没有Image对象，但是小程序的Image组件还是有提供binderror和bindload事件，可以绕一下，把需要预加载的图片直接写在一个页面上，然后上面覆盖loading图，当所有图片load事件返回之后再把loading去掉就可以了，但是因为上线时间比较紧就没有加预加载 图片资源转为base64吧第二个想法就是转base64吧。直接用webpack转吧，在webpack.base.conf.js中找到url-loader把图片的limit弄大一点，100K吧1234567&#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 102400 &#125;&#125;, 然后看一眼打包之后的代码，发现并没有生效，代码里的图片还是链接，但是控制台明明显示所有图片都emitted了，而且直接输出到了文件夹，好像并没有经过url-loader处理，在issues上搜下发现也有人遇到同样的问题，然后维护者说mpvue-loader处理后直接emitfile 了，没发送给其他图片loader处理，坑~最终还是手动把部分小的图标转成了base64，然后现在代码里面看起来就一坨坨的 小总结 具体问题其实并没有定位到，Image加载没有报错 跟图片大小无关，大小图片偶有无法加载出来的时候 无论是预加载和base64两个方向应该都是有问题的，毕竟小程序已经把所有本地资源下载好了，不应该是网络问题，而且转base64后解析应该更耗性能了，但是加载空白的问题几乎不再有 小程序文档在性能优化那里强调目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面，但是和这次表现不符合 后面可以实现一个小程序版的图片预加载 设计要求界面上使用特定字体因为眼疾手快是一款对外的教育类游戏，设计对界面还是有一定的要求，其中就提到希望界面上固定的文案能够使用圆体，这样整体UI会比较有感觉。第一想法就是上iconfont.cn上转换和下载，但是发现网站上提供的字体有限，并没有圆体，那就只能寻找别的字体源，而且因为中文字体库太庞大，还得做字体提取。字蛛是一个开源的中文字体压缩器，它可以吧html中用到的字进行提取和压缩，用不到的就过滤掉，这样就能把整个ttf字体进行强而有力的压缩，这个项目里面我使用到的字体压缩之后就只有4k。而且小程序不支持本地加载字体文件，只能把字体放在网络上通过链接引用，或者使用wx.loadFontFace来异步加载，因为考虑到异步会有延迟，所以直接就直接把字蛛切割后的ttf文件在transfonter.org上转换成base64引入，这样就实现了设计使用特殊字体的要求。 登录授权逻辑微信为了保护用户隐私，对wx.getUserInfo做了限制，withCredentials字段必须在wx.login且登录态未过期的时候才生效，而wx.login的有效期为5分钟，该api为静默调用，用户没有任何感知，而且小程序不会再主动调起授权弹窗，授权弹窗必须通过button组件设置open-type=&quot;getUserInfo&quot;来调用，这就形成了一个迷之逻辑，wx.login由开发者主动调用而且只有5分钟有效期而且得在getUserInfo之前，getUserInfo目前只能通过button组件让用户主动触发，如果五分钟后用户还没有调用button组件，wx.login的登录态就失效了。最终我的做法就是一进入应用就主动调用login，然后首页的每一个按钮都设置open-type=&quot;getUserInfo&quot;，然后在回调里再调一次login，这样如果登录态已经失效，用户再次掉起授权的时候就能确保登录态是有效的了 游戏二维码]]></content>
      <tags>
        <tag>小程序</tag>
        <tag>项目小结</tag>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构描述]]></title>
    <url>%2F2018%2F12%2F30%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[来自于《数据结构与算法JavaScript描述》读书整理，对前端工程师该书是比较好的数据结构与算法入门书。 数据结构这部分介绍了以下数据结构，以及其在JavaScript中的实现方式和简单应用：数组，列表，栈，队列，链表，字典，散列，集合，二叉树和二叉查找树，图。 列表列表。列表是一组有序的数据，每个列表中的数据项称为元素。列表的抽象数据类型定义： 方法 定义 length 返回列表的元素个数 append 在列表的末尾添加新元素 find 在列表中查找元素 remove 从列表中删除元素 clear 清空列表中的所有元素 toString 返回列表的字符串形式 insert 在现有元素后面插入新元素 currPos 返回列表的当前位置 front 将列表的当前位置移动到第一个元素 end 将列表的当前位置移动到最后一个元素 prev 将列表的当前位置前移一位 next 将列表的当前位置后移一位 hasPrev 判断是否有前一位 hasNext 判断是否有后一位 moveTo 将当前位置移动到指定位置 查看实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class List &#123; constructor() &#123; this._dataStore = []; this._listSize = 0; this._pos = 0; &#125; length() &#123; return this._listSize; &#125; append(el) &#123; this._dataStore[this._listSize++] = el; &#125; find(el) &#123; return this._dataStore.findIndex(item =&gt; item == el); &#125; remove(el) &#123; const foundAt = this.find(el); if (foundAt &gt; -1) &#123; this._dataStore.splice(foundAt, 1); --this._listSize; &#125; &#125; clear() &#123; this._dataStore = []; this._pos = this._listSize = 0; &#125; toString() &#123; return this._dataStore.join(); &#125; insert(el, after) &#123; const foundAt = this.find(after); if (foundAt &lt; 0) return false; this._dataStore.splice(foundAt, 0, el); this._listSize++; return true; &#125; currPos() &#123; return this._pos; &#125; front() &#123; this._pos = 0; return this.currPos(); &#125; end() &#123; this._pos = this._listSize - 1; return this.currPos(); &#125; hasNext() &#123; return this._pos &lt; this._listSize - 1; &#125; hasPrev() &#123; return this._pos &gt; 0; &#125; prev() &#123; if(this.hasPrev()) --this._pos; return this.currPos(); &#125; next() &#123; if(this.hasNext()) ++this._pos; return this.currPos(); &#125; moveTo(pos) &#123; if (0 &lt;= pos &amp;&amp; pos &lt; this._listSize) &#123; this._pos = pos; return this.currPos(); &#125; else &#123; return -1; &#125; &#125;&#125; 栈栈。栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一段称为栈顶。栈被称为一种后入先出的数据结构。 方法 定义 length 返回栈内元素个数 push 元素入栈 pop 元素出栈 peek 返回栈顶元素 empty 返回栈内是否为空 clear 清空栈内元素 查看实现代码 1234567891011121314151617181920212223class Stack &#123; constructor() &#123; this._dataStroe = []; this._top = 0; &#125; length() &#123; return this._top; &#125; push(el) &#123; this._dataStroe[this._top++] = el; &#125; pop() &#123; --this._top; return this._dataStroe.pop(); &#125; peek() &#123; return this._dataStroe[this._top - 1]; &#125; clear() &#123; this._dataStroe = []; this._top = 0; &#125;&#125; 队列队列。队列是一种列表，不同的是队列只能在队尾插入元素，在对首删除元素，队列用于存储按顺序排列的数据，先进先出。在列表的实际使用中有时还会遇到需要插队的情况，这种数据结构叫做优先队列，出队伍的时候优先权最高的元素先出。 方法 定义 length 返回队列元素的个数 toString 显示队列内所有元素 enqueue 入队 dequeue 出队 front 读取对首元素 end 读取对尾元素 empty 判断队伍是否为空 查看实现代码 1234567891011121314151617181920212223242526272829class Queue &#123; constructor() &#123; this._dataStore = []; &#125; length() &#123; return this._dataStore.length; &#125; toString() &#123; return this._dataStore.join(); &#125; enqueue(el) &#123; this._dataStore.push(el); &#125; dequeue() &#123; return this._dataStore.shift(); &#125; front() &#123; return this._dataStore[0]; &#125; end() &#123; return this._dataStore[this._dataStore.length - 1]; &#125; empty() &#123; return !this._dataStore.length; &#125; toString() &#123; return this._dataStore.join(); &#125;&#125; 链表链表。链表是由一组节点组成，每个节点都使用一个对象的引用指向它的后继，指向另一个节点的引用叫做链。需要拿链表和数组做一个对比，在很多编程语言中数组有很大的局限，数组被实现成的长度是固定的，这样当数组被填满后再舔新元素会很麻烦，而且操作数组也不像js一样有能直接使用的api。在js中数组的最大问题是被实现成了对象，相对其他编程语言，js的数组效率更低。当你觉得js中的数组在实际中使用很慢的时候，就可以考虑使用链表，除了对数据的随机访问，链表几乎可以使用在任何可以使用一维数组的情况中。 方法 定义 head 头节点 find 寻找节点 findPrev 寻找上一个节点 insert 插入节点 remove 删除节点 display 显示链表中的元素 查看实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Node(el) &#123; this.element = el; this.next = null;&#125;class LList &#123; constructor() &#123; this._head = new Node('head'); &#125; find(item) &#123; let currentNode = this._head; while(currentNode.element != item) &#123; currentNode = currentNode.next; &#125; return currentNode; &#125; insert(newEl, item) &#123; const newNode = new Node(newEl); const currentNode = this.find(item); newNode.next = currentNode.next; currentNode.next = newNode; &#125; findPrev(item) &#123; let currentNode = this._head; while(!(currentNode.next == null) &amp;&amp; (currentNode.next.element != item)) &#123; currentNode = currentNode.next; &#125; return currentNode; &#125; remove(item) &#123; const prevNode = this.findPrev(item); if (!(prevNode.next == null)) &#123; prevNode.next = prevNode.next.next; &#125; &#125; display() &#123; let currentNode = this._head; const arr = []; arr.push(currentNode.element); while(currentNode.next != null) &#123; currentNode = currentNode.next; arr.push(currentNode.element); &#125; return arr; &#125;&#125; 字典字典。字典是一种以键-值对形式存储数据的数据结构 方法 定义 add 增加字典中的元素 find 寻找字典中的元素 remove 移除字典中的元素 showAll 展示字典中的所有元素 查看实现代码 1234567891011121314151617class Dictionary &#123; constructor() &#123; this._dataStore = []; &#125; add(key, value) &#123; this._dataStore[key] = value; &#125; find(key) &#123; return this._dataStore[key]; &#125; remove(key) &#123; delete this._dataStore[key]; &#125; showAll() &#123; return this._dataStore; &#125;&#125; 散列表散列。散列是一种常用的数据存储技术，散列后的数据可以快速地插入或者使用。散列使用的数据结构叫做散列表。在js中用数组来实现散列表，数组的长度是预先设定的，理想状况下散列函数会将每个键值映射成一个唯一的数组索引，并且将键均匀地映射到数组中。但是即便散列函数很高效，还是会存在将两个键值映射成同一个值得可能，这种现象叫做碰撞。实现一个散列表首先要确定的是数组的长度和散列函数。 集合集合是一种包含不同元素的数据结构。集合中的元素称为成员，集合中两个最重要的特性是： 首先，集合中的成员是无序的；其次，集合中不允许相同的成员存在。js中可以通过Set对象实现集合 二叉查找树树。树是一种非线性的数据结构，以分层形式存储数据，数被用来存储具有层级关系的数据。一棵树中最上面的节点称为根节点，如果一个节点下面连接多个节点，那么这个节点称为父节点，它下面的节点叫做子节点，没有任何子节点的节点称为叶子节点。树的层数叫做数的深度，从一个节点到另一个节点的一组边叫做路径，以某种方式访问树中所有的节点叫做树的遍历。二叉树是一种特殊的树，它的子节点树不超过两个，二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。 方法 定义 insert 给二叉查找树增加节点 find 寻找节点 inOrder 给返回排序后的节点 insert 插入节点 getMin 获取最小节点 getMax 获取最大节点 查看实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function Node (data, left, right) &#123; this.data = data; this.left = left; this.right = right; this.show = () =&gt; this.data;&#125;class BST &#123; constructor() &#123; this._root = null; &#125; insert(data) &#123; const n = new Node(data, null, null); if (this._root == null) &#123; this._root = n; &#125; else &#123; let current = this._root; let parent; while(true) &#123; parent = current; if (data &lt; current.data) &#123; current = current.left; if (current == null) &#123; parent.left = n; break; &#125; &#125; else &#123; current = current.right; if (current == null) &#123; parent.right = n; break; &#125; &#125; &#125; &#125; &#125; find(data) &#123; let current = this._root; while(current != null) &#123; if (current.data == data) &#123; return current; &#125; else if (data &lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return null; &#125; inOrder (node) &#123; if (node != null) &#123; this.inOrder(node.left); console.log(node.show()); this.inOrder(node.right); &#125; &#125; getMin() &#123; let current = this._root; while(!(current.left == null)) &#123; current = current.left; &#125; return current.data; &#125; getMax() &#123; let current = this._root; while(!(current.right == null)) &#123; current = current.right; &#125; return current.data; &#125;&#125; 图图。图是由边的集合及顶点的集合组成。顶点有权重也称为成本，边由顶点对定义，如果边有方向，图就叫有向图，反之叫做无向图。图中一系列的顶点构成路径，路径中所有的顶点都由边连接。路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示。由指向自身的顶点组成的路径称为环，环的长度为0。圈是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同。只要是没有重复边或重复顶点的圈，就是一个简单圈，反之称为平凡圈。如果两个顶点之间有连接，那么这两个顶点就是强连通的。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electron 开发]]></title>
    <url>%2F2018%2F10%2F21%2Felectron%2F</url>
    <content type="text"><![CDATA[electron框架可以让你用JavaScript/Html/Css等网站相关技术，非常快速而容易地搭建一个原生应用。我们熟悉的Vscode，Atom，github desktop等常见软件都是使用electron搭建的，而且electron还是一个多平台框架，一份代码可以同时打包出适用于Mac, Windows 和 Linux三个平台的原生应用。目前electron的star数已经将近66k，生态已经非常成熟。 Electron = node + chromiumelectron使用web页面作为应用的GUI，其原理就是自己定制一个浏览器，让我们的web代码跑在这个定制的浏览器上面，electron使用的是chromium浏览器，我们写的页面就是跑在这个浏览器上的，所有的node api包括第三方模块都可以在electron中使用。这样子node + chromium就构成了我的的原生应用 主进程和渲染进程 主进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建窗口，创建系统菜单等 渲染进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。 主进程和渲染进程红可以使用的api 进程间通讯electron提供ipc模块进行进程间通讯如上图所示，ipc是一个一对多的传播机制，具体传播机制如下 渲染进程订阅传播事件 主进程发送消息 渲染进程接收消息 12345678// 主进程中广播sayInfo事件，const window = new BrowserWindow()window.webContents.send('sayInfo', 'Hi')// 在window中订阅sayInfo事件，并把返回值打印出来ipcRenderer.on('sayInfo', info =&gt; &#123; console.log(info) // Hi&#125;) 渲染进程向主进程通讯如上图所示： 渲染进程订阅传播事件 主进程发送消息 渲染进程接收消息 123456// 主进程中订阅sayInfo事件，处理回调ipcMain.on('sayInfo', (event, info) =&gt; &#123; console.log(info) // Hi &#125;);// 渲染进程中广播sayInfo事件，传递参数ipcRenderer.send('sayInfo', 'Hi'); 渲染进程之间通讯 渲染进程之间不允许直接通讯，要通过主进程作为媒介，比如rendererA要向rendererB传递消息，只能先传给主进程，主进程再广播给rendererB 多任务并行 在渲染进程中可以使用web worker，但是可能会有崩溃，内存溢出等问题 可以使用child_process创建子进程，但是在子进程中不能使用electron中的api 可以新建一个隐藏的渲染进程，在里面处理逻辑 数据存储因为electron的本质是chromium浏览器，所以浏览器自身的数据存储方式像Cookies，Local Storage，Session Storage，IndexedDB都可以使用，但是因为有node的加持，我们也可以使用第三方的嵌入式数据库，比如NeDB，LowDB等 应用更新electron生态圈里有相应的更新模块，比如electron-updater， electron-custom-updater等，同时也可以有简单粗暴的方式，当有新版本的时候，直接下载然后退出安装，同时也可以通过更换asar包的方式，速度更快]]></content>
      <tags>
        <tag>electron</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用wepy快速上手开发小程序]]></title>
    <url>%2F2018%2F04%2F17%2Fwepy-quick-start%2F</url>
    <content type="text"><![CDATA[公司最近需要快速开发多个小程序，为了尽量减少大家的上手时间，我们决定使用使用wepy框架来进行小程序开发。作为一个初次接触小程序并且不是使用原生小程序框架来开发的新手，我建议大家要熟读小程序官方文档，熟悉小程序的逻辑层配置，熟悉小程序的API，熟悉小程序的组件，因为小程序本身的限制，文档里面有很多tip和注意事项，官方都给出了标注和避免的方法，如果没有仔细查看文档很容易在实际操作中踩坑 Vscode代码高亮设置我们公司前端使用的IDE是Vscode，首先要设置代码高亮，对于.wpy文件，设置方法如下：1.在 Code 里先安装 Vue 的语法高亮插件 Vetur。2.把.wpy 关联的语言模式选择为 Vue。3.因为wepy有自己的标签和像素单位， Vetur会根据vue的规则当成错误来提示，mac下使用快捷键 ⌘ ,，打开工作区设置，粘贴下面的规则，把Vue的template和style校验关掉1234&#123; "vetur.validation.style": false, "vetur.validation.template": false&#125; 另外.wxs文件直接关联为js，如果是使用原生小程序开发，.wxml文件关联为html，wxss文件关联为css 微信开发者工具配置1.使用微信开发者工具新建项目，本地开发选择dist目录2.微信开发者工具–&gt; 项目 –&gt; 项目设置中，取消勾选ES6 转 ES5，上传代码时样式自动补全，代码上传时自动压缩3.微信开发者工具–&gt; 项目 –&gt; 项目设置中，勾选不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书4.开发过程中，可以通过自定义编译，自定义场景值快速进入到某个页面开发 启动项目及项目结构1234npm install wepy-cli -gwepy init standard myprojectcd myprojectwepy build --watch 项目目录结构1234567891011├── dist 小程序运行代码目录（该目录由WePY的build指令自动编译生成，请不要直接修改该目录下的文件）├── node_modules ├── src 代码编写的目录（该目录为使用WePY后的开发目录）| ├── components WePY组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy 可复用的WePY组件a| | └── com_b.wpy 可复用的WePY组件b| ├── pages WePY页面目录（属于完整页面）| | ├── index.wpy index页面（经build后，会在dist目录下的pages目录生成index.js、index.json、index.wxml和index.wxss文件）| | └── other.wpy other页面（经build后，会在dist目录下的pages目录生成other.js、other.json、other.wxml和other.wxss文件）| └── app.wpy 小程序配置项（全局数据、样式、声明钩子等；经build后，会在dist目录下生成app.js、app.json和app.wxss文件）└── package.json 项目的package配置 wepy与小程序不一样的地方1.框架在app.wpy的constructor中使用中间件this.use(&#39;promisify&#39;);，可以对小程序提供的API全都进行Promise化，比如wx.login()可以直接写成wepy.login()就返回了一个Promise：wepy.login().then(()=&gt;{}).catch(err=&gt;{})2.框架在app.wpy的constructor中使用中间件this.use(&#39;requestfix&#39;);，可以修复小程序请求最大并发数为5的问题3.事件绑定语法使用优化语法代替。原bindtap=&quot;click&quot;替换为@tap=&quot;click&quot;，原catchtap=&quot;click&quot;替换为@tap.stop=”click”。原capture-bind:tap=&quot;click&quot;替换为@tap.capture=”click”，原capture-catch:tap=&quot;click&quot;替换为@tap.capture.stop=”click”4.事件传参使用优化后语法代替。原bindtap=&quot;click&quot; data-index={ {index} }替换为@tap=&quot;click({ {index} })&quot;5.数据绑定不用通过setData方法，可以直接赋值，但是在异步函数中更新数据的时，必须手动调用$apply方法，才会触发脏数据检查流程的运行1234567891011// 在原生小程序中this.setData(&#123;title: 'this is title'&#125;);// wepy直接赋值即可this.title = 'this is title';// 但是wepy在异步函数中更新数据要手动调用$applysetTimeout(() =&gt; &#123; this.title = 'this is title'; this.$apply();&#125;, 3000); wepy与vue不一样的地方1.wepy中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的，自定义的方法应该在methods对象外声明，与methods平级123456789export default class MyComponent extends wepy.component &#123; // methods对象只能声明页面`wxml`标签的`bind、catch`事件 methods = &#123; bindtap () &#123;&#125;, bindinput () &#123;&#125;, &#125; // 普通自定义方法在methods对象外声明，与methods平级 customFunction () &#123;&#125;&#125; 2.静态组件问题：WePY中的组件都是静态组件，是以组件ID作为唯一标识的，每一个ID都对应一个组件实例，当页面引入两个相同ID的组件时，这两个组件共用同一个实例与数据，当其中一个组件数据变化时，另外一个也会一起变化，如果需要避免这个问题，则需要分配多个组件ID和实例12345678&lt;template&gt; &lt;view class="child1"&gt; &lt;child&gt;&lt;/child&gt; &lt;/view&gt; &lt;view class="child2"&gt; &lt;anotherchild&gt;&lt;/anotherchild&gt; &lt;/view&gt;&lt;/template&gt; 123456789101112&lt;script&gt; import wepy from 'wepy'; import Child from '../components/child'; export default class Index extends wepy.component &#123; components = &#123; //为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题 child: Child, anotherchild: Child &#125;; &#125;&lt;/script&gt; 3.组件循环渲染，必须使用wpy的辅助标签&lt;repeat&gt;1234567&lt;template&gt; &lt;!-- 注意，使用for属性，而不是使用wx:for属性 --&gt; &lt;repeat for="&#123;&#123;list&#125;&#125;" key="index" index="index" item="item"&gt; &lt;!-- 插入&lt;script&gt;脚本部分所声明的child组件，同时传入item --&gt; &lt;child :item="item"&gt;&lt;/child&gt; &lt;/repeat&gt;&lt;/template&gt; 4.wxs 目前主要是增强 wxml 标签的表达能力，可以使用wxs替代vue中的filters - wxs必须是外链文件。并且后缀为`.wxs`。 - wxs引入后只能在`template`中使用，不能在`script`中使用 utils.wpy：12345module.exports = &#123; transformSex: function(id) &#123; return +id === 1 ? '男' : '女'; &#125;&#125;; 在组件中使用utils.wpy：1234&lt;view&gt; &lt;text&gt;&#123;&#123;utils.transformSex(sex)&#125;&#125;&lt;/text&gt; &lt;!--男--&gt;&lt;/view&gt; 1234567891011import wepy from 'wepy';import utils from '@/wxs/utils.wxs';export default class Text extends wepy.component &#123; data = &#123; sex: 1 &#125;; wxs = &#123; utils: utils &#125;;&#125; 常用的小程序组件的一些tip1.textarea、map、canvas、video 这四个组件是客户端的原生组件，层级最高，不能通过z-index控制层级2.scroll-view中不能使用滚动无法触发无法触发 onPullDownRefresh 事件，scroll-view中也不能使用1中的四个客户端原生组件3.除了文本节点&lt;text&gt;以外的其他节点都无法长按选中4.如果需要发送模板消息，需要在form表单中设置report-submit属性为true，收集formId5.input组件是native组件，字体是系统字体，无法设置 font-family 使用wepy-redux进行数据管理wepy支持使用wepy-redux来进行数据状态管理，在脚手架init的时候会询问用户是否使用redux，同意即可。wepy-redux主要用connect(states, actions)来连接组件和store，具体用法可以参考wepy-redux文档和脚手架init出来的demo；wepy使用redux-actions来创建action，让action书写起来更加友好，具体使用方法也可以参考wepy-actions文档和脚手架init出来的demo 小程序登录逻辑小程序的登录逻辑是比较通用的但是流程比较复杂，这里贴一下我们项目中的登录逻辑]]></content>
      <tags>
        <tag>wepy</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现逐帧动画]]></title>
    <url>%2F2016%2F08%2F20%2Fhttps%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[主要理解下面两点： 1.http和https的区别；2.https具体解决了那些问题 HTTP都有哪些问题HTTP最大的问题就是数据没有加密和通信双方不能互相验证身份，对应以下场景👇 信息泄露。HTTP是可以被拦截的，假如你的上网方式被人家控制了（比如连接匿名WiFi），那你的所有信息都有可能被拦截到 网站劫持。很常见的就是被运营商的广告劫持了，当我们上一个网站的时候莫名其妙地弹出一个广告（这个广告并不是这个网站的），这就是因为我们访问的页面被运营商劫持，加入了他自己的东西 HTTPS如何解决问题先从加密说起：HTTP没有加密信息，中间人拦截之后就可以知道传输的信息了，比如当你登录的时候把账目和密码通过网络传输，如果手机是接入了被监控的WIFI，那敏感信息就可以被拦截了 1️⃣第一种加密信息尝试：对称加密 客户端和服务器都有一把一样的钥匙，传输的时候先加密，这样子别人拦截到的信息是加密之后的，他没有钥匙无法解密信息。但是不可能钥匙永远都是一把，如果一方保管不善，泄密了就完了。所以最好的做法就是每一次传输都生成一把钥匙。信息传输之前，先让客户端和服务器先碰一下头，交换彼此的钥匙，然后用钥匙加密之后再传输数据。但是钥匙也是直接传输的，被劫持之后也凉了 2️⃣第二种加密信息尝试：非对称加密 服务器有一把自己的钥匙叫做私钥，然后客户端也有一把钥匙叫做公钥，公钥是公开的，所有人都知道。私钥加密的信息公钥都可以解密，公钥加密的信息只有私钥才能解密，这样就保证了只有服务器才能拿到传输的信息 过程如下： 客户端向服务器要公钥 服务器给出公钥 客户端利用公钥加密数据传给服务器 服务器利用私钥解密数据，然后把返回的数据用私钥加密 客户端拿到加密数据用公钥解密 问题出在第二步，客户端如何确定自己拿到的公钥，真的就是是自己服务器生成的公钥？中间人也可以搞一套，自己生成一个公钥给客户端，然后自己发一个请求去服务器要一个公钥，客户端利用中间人的公钥加密数据传输，中间人用自己的私钥解密之后，再用服务器的公钥加密传给服务器，然后拿到服务器返回的数据，再把这个数据传给客户端，这样一来，所有的信息也还是经过了中间人，也凉了 3️⃣确保拿到的公钥是自己服务器生成的公钥 举例，你去坐高铁的时候如何证明你是你？答案是用公安局身份证。客户端在拿到传送过来的公钥的时候让服务器把自己的身份证出示一下，这个身份证就是服务器CA证书。让自己的服务器去公安局那里拿一个身份证，上面有服务器的一些信息，比如域名，过期时间等，客户端收到服务器发过来的CA证书的时候，我只要核对CA证书的真伪，那我就知道我能不能信赖你 4️⃣那客户端如何校验服务器发过来的CA证书的真伪？ 举个例子，在你请假的时候让你的领导在请假条上签一个名，当HR看到假条上签名的时候就知道领导同意你请假了，CA证书的真伪也可以通过计算机的数字化签名来实现。下面也是通过非对称加密来生成签名和解密签名： 服务器将自己的域名、IP等信息提交给 CA 审查 CA 审查无误，使用私钥把服务器信息的摘要加密，生成的密文就是所谓签名 CA 把服务器的信息、签名、有效期等信息集合到一张证书上，颁发给服务器 服务器每次发信息的时候把自己的CA证书也传给客户端 客户端收到服务器发送的证书后，使用CA的公钥解密签名，获得服务器信息的摘要，如果和证书上记录的服务器信息的摘要一致，说明服务器信息是经过CA认可的 5️⃣那客户端如何解密CA证书？ 来自浏览器，全球的CA证书颁发机构就那几家，公钥都直接预装在浏览器上了 HTTPS的数据传输过程前期准备工作： 客户端（操作系统/浏览器） 自带了CA根证书（解密签名的公钥） 服务器自己去机构里领取一张带有数字签名的CA证书 每一次数据传输的过程： 客户端要发数据前去服务器那里要公钥+CA证书 服务器返回本次传输的公钥和服务器自己的CA证书 客户端用自己的CA公钥去解密传过来的CA证书的签名，解密出来的信息和证书上的信息一致，那就说明送过来的公钥是自己服务器上的公钥，可以信赖这个公钥 客户端用公钥加密数据传给服务器 服务器用私钥去解密信息，然后把返回信息用私钥加密传回去 客户端用公钥解密返回的数据，整个传输过程完成]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG实现描边动画]]></title>
    <url>%2F2016%2F06%2F06%2FSVG%E5%AE%9E%E7%8E%B0%E6%8F%8F%E8%BE%B9%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[说起SVG，我是恨它又爱它，恨它是因为刚开始接触的时候自己傻B地想用代码去写它，其实在web上我们用它做交互也只是用了几个常用的特性而已，其他的标签知道这么一回事就成了，其实说白了它就是一种图片格式，你得去画它，网站上最长用的SVG交互效果就是描边动画了，今天就来实现它 先上效果图：思路：要实现这种动画，我们要使用的是SVG的路径path标签，其中然后配合两个属性：stroke-dasharray和stroke-dashoffset，至于用什么方式实现动画效果就八仙过海了，我这里使用的是css3的animation 第一步：了解SVG的path中文的意思就是路径，描边动画嘛，你得先给个路线我才能描边啊，路径就是这个路线：先上网找个图片，放进AI里面，然后用钢笔勾勒路径，再把图片删掉，剩下路径，把它另存为svg，然后把它拖进编译器里，就能看到一堆代码，我们只要保留其中的path就好（不会用AI的给你个理由去勾搭设计师美眉） 第二步：了解stroke-dasharray和stroke-dashoffset理解字面意思就好：stroke-dasharray：就是把线条断开为虚线，下图就是我把stroke-dasharray设置为10的效果，它就变成虚线了，数值越大，线就越长stroke-dashoffset：就是设置线条的偏移，设置了这个值后，线段就会偏移相应的值，我们要实现动画只要动态改变这个偏移值就好，那样线条就会动起来了 第三步：利用@keyframes实现动态描边12345678910@keyframes describe&#123; from&#123; stroke-dashoffset: 1000; opacity: 1; &#125; to&#123; stroke-dashoffset: 0; opacity: 0; &#125;&#125; 额~~有点快，没关系，明白意思就好，最后，描边完成之后再插入一个动画，让背景图片淡入，最终效果如下：下班了，不调了，如果再慢点效果估计更好 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;super&lt;/title&gt; &lt;script src="vivus.js"&gt;&lt;/script&gt; &lt;style&gt; .super_logo&#123; position: absolute; opacity: 0; animation:fadeIn 1s ease-in forwards; -webkit-animation:fadeIn 1s ease-in forwards; &#125; #super&#123; position: absolute; z-index: 1; stroke-dasharray: 800; stroke-dashoffset: 1000; animation: describe 2s forwards; -webkit-animation: describe 2s forwards; &#125; @keyframes fadeIn&#123; from&#123;opacity: 0;&#125; 80%&#123;opacity: 0.5;&#125; to&#123;opacity: 1;&#125; &#125; @-webkit-keyframes fadeIn&#123; from&#123;opacity: 0;&#125; 80%&#123;opacity: 0.5;&#125; to&#123;opacity: 1;&#125; &#125; @keyframes describe&#123; from&#123; stroke-dashoffset: 1000; opacity: 1; &#125; to&#123; stroke-dashoffset: 0; opacity: 0; &#125; &#125; @-webkit-keyframes describe&#123; from&#123; stroke-dashoffset: 1000; opacity: 1; &#125; to&#123; stroke-dashoffset: 0; opacity: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style="background:#0f1a3a;"&gt;&lt;img src="http://images2015.cnblogs.com/blog/754767/201606/754767-20160606165217980-1558570494.gif" alt="super" class="super_logo"&gt;&lt;svg id="super" x="0px" y="0px" width="293px" height="200px" viewBox="0 0 293 200"&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M67.667,39.667c0,0-33.334,17.333-46.667,36.667 c0,0,33.007,40.458,43.331,50.018c19.419,17.982,65.002,55.316,82.169,59.982c0,0,27.834-11.334,49.834-30.667S249,113,261,100 s9.334-12.333,15.334-22.333c0,0-21.333-29.333-44-38c0,0-162.001-5.334-163.334-2.667"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M169.667,50.333c0,0-71.334-2.667-74.667,8.667s42,14,42,14 s55.333,4.667,60,6.667s32.668,7.254,43.334,31.627L255,93.667C255,93.667,217,59,169.667,50.333z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M75.667,123c0,0,42,8,78,8.667s32.667,10.667,32.667,10.667 S185.333,155,146.5,153.667S75.667,123,75.667,123z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M45,93c0,0-12.667-24,34-48h-8.667c0,0-35.455,24.559-36,35.677L45,93 z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M174.912,161c0,0-24.745,12.999-24.745,12.333 s-15.25-4.249-20.583-10.416"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M130,162.667c0,0,1.75-3.083,13.667-1.25c0,0,30,0.836,30.75-0.582"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M177.75,43L224,45.5c0,0,7.5,12.125-13,8.625S177.75,43,177.75,43z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M237.25,52c0,0,2.75,20.375,21.875,35.625l5.75-6.948 C264.875,80.677,249.273,55.266,237.25,52z"/&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 恩恩~~写到这里我的肚子饿惨了，他们都下班去吃饭了，打字这么开心我干脆再介绍个插件，那就vivus.js Vivus是一款可以执行SVG路径动画的轻量级Javascript库，github地址：https://github.com/maxwellito/vivus 扔个中文的介绍http://www.htmleaf.com/html5/SVG/201501261279.html 写的还可以，我就不重复码字了，直接上demo： 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;super&lt;/title&gt; &lt;script src="vivus.js"&gt;&lt;/script&gt; &lt;style&gt; .super_logo&#123; position: absolute; &#125; #super&#123; position: absolute; z-index: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style="background:#0f1a3a;"&gt;&lt;img src="super.gif" alt="super" class="super_logo"&gt;&lt;svg id="super" x="0px" y="0px" width="293px" height="200px" viewBox="0 0 293 200"&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M67.667,39.667c0,0-33.334,17.333-46.667,36.667 c0,0,33.007,40.458,43.331,50.018c19.419,17.982,65.002,55.316,82.169,59.982c0,0,27.834-11.334,49.834-30.667S249,113,261,100 s9.334-12.333,15.334-22.333c0,0-21.333-29.333-44-38c0,0-162.001-5.334-163.334-2.667"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M169.667,50.333c0,0-71.334-2.667-74.667,8.667s42,14,42,14 s55.333,4.667,60,6.667s32.668,7.254,43.334,31.627L255,93.667C255,93.667,217,59,169.667,50.333z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M75.667,123c0,0,42,8,78,8.667s32.667,10.667,32.667,10.667 S185.333,155,146.5,153.667S75.667,123,75.667,123z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M45,93c0,0-12.667-24,34-48h-8.667c0,0-35.455,24.559-36,35.677L45,93 z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M174.912,161c0,0-24.745,12.999-24.745,12.333 s-15.25-4.249-20.583-10.416"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M130,162.667c0,0,1.75-3.083,13.667-1.25c0,0,30,0.836,30.75-0.582"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M177.75,43L224,45.5c0,0,7.5,12.125-13,8.625S177.75,43,177.75,43z"/&gt; &lt;path fill="none" data-duration="60" stroke="#ffffff" stroke-width="1" d="M237.25,52c0,0,2.75,20.375,21.875,35.625l5.75-6.948 C264.875,80.677,249.273,55.266,237.25,52z"/&gt;&lt;/svg&gt;&lt;script&gt;window.onload=function()&#123; var toPlay= new Vivus('super', &#123; type: 'delayed', duration: 50, start: 'autostart', forceRender: false, dashGap: 20&#125; ); var oSuper=document.getElementById('super'); oSuper.addEventListener('click',function()&#123; toPlay.reset().play(); &#125;);&#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测PC端和移动端的方法总结]]></title>
    <url>%2F2016%2F06%2F02%2F%E6%A3%80%E6%B5%8BPC%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[正在苦逼的实习中，昨天公司让做一个页面，涉及到检测终端的问题，如果是手机设备，就跳转到指定的网页上，以前写响应式布局只要用@media screen来实现布局的差异化适应，但是现在不仅仅是布局，还要针对移动端做一些别的动作，所以看了点资料，做个总结 还是用@media screen思路：css使用媒体查询，当屏幕小于760px时，使某个元素的样式发生改变，然后通过js检测到这个改变，就可以知道现在切换到移动端了css代码：1234/* 检测小屏幕- */@media only screen and (max-width: 760px) &#123; #some-element &#123; display: none; &#125;&#125; js代码：123456789$( document ).ready(function() &#123; var isMobile = false;//默认是pc端 if( $('#some-element').css('display')=='none') &#123; is_mobile = true; &#125; if (isMobile == true) &#123; //对移动端进行处理 &#125;&#125;); 通过navigator.userAgent字符串检测思路：Navigator对象包含有关浏览器的信息，通过检测userAgent字符串，然后使用正则表达式进行匹配，我们自然就能知道用户是否在使用移动端的浏览器啦先上个简化版的，意思意思下：12345678var isMobile = false;// 检测userAgentif( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) &#123; isMobile = true;&#125;if(isMobile)&#123; //移动端的处理逻辑&#125; 其实还可以用jQuery,但是jQuery从1.9版开始，移除了$.browser和$.browser.version：1$.browser.device = (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase(); 通过上面那段代码基本就能检测到我们能常用的移动终端了，但是后来我在stackoverflow发现一哥们检测得更加全面牛逼：12345678var isMobile = false;//默认PC端// 检测userAgentif(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4)))&#123; isMobile = true;&#125;if(isMobile)&#123;&lt;br&gt; //移动端的处理逻辑&lt;br&gt;&#125; 通过Window.matchMedia()检测思路：Window.matchMedia()用来检查mediaquery语句，。它返回一个MediaQueryList对象。该对象有两个属性media：查询语句的内容。matches：如果查询结果为真，值为true，否则为false12345var isMobile = false;//默认PC端var result = window.matchMedia("&lt;code&gt;only screen and&lt;/code&gt; (max-width: 760px)");if (result.matches)&#123; isMobile = true;&#125; 如果在PC端上使用Window.matchMedia()的话IE10以下是不支持的，但是我们只是用来检测终端哈，IE不支持就算了，移动端上安卓3.0以上都没有问题，so~~ 检测移动端的TouchEvent事件思路：使用document.createEvent()创建TouchEvent事件，如果成功那就是移动端了，返回true，pc端是没有TouchEvent事件的，所以会出错，返回false1234567891011var isMobile = false;//默认PC端function mobile() &#123; try&#123; document.createEvent("TouchEvent"); return true; &#125; catch(e)&#123; return false; &#125;&#125;isMobile=mobile(); 使用Device.js库这个库就没啥好讲的了，自己跟着套代码就ＯＫgithub地址 https://github.com/matthewhudson/device.js不想看英文的孩子，扔个中文教程 https://segmentfault.com/a/1190000000373735]]></content>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现逐帧动画]]></title>
    <url>%2F2016%2F06%2F01%2Fcss%E5%AE%9E%E7%8E%B0%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[css3里面的animation属性非常强大，但是自己用的比较少，最近有次面试就刚好被问到了，趁现在有时间就对animation做一个小总结。同时实现一个逐帧动画的demo作为练习 animation属性一览因为animation属性比较多，干脆也做了一份导图，以后想查看，就一目了然了 keyframes实现帧动画熟悉了animation的属性之后，得找个简单的小项目实现下，逐帧动画好有意思，先跑一个满足下自己。思路很简单，就是给元素一个雪碧图的背景，然后添加的帧动画更改background-position，关键代码：12345678910111213141516@keyframes run&#123; from&#123; background-position: 0 0; &#125; to&#123; background-position: -1540px 0 ; &#125;&#125;div&#123; width:140px; height:140px; background: url(run.png); animation-name：run; animation-duration:1s; animation-iteration-count:infinite;&#125; 但是跑起来后我们发现，每帧动画之间帧动画都是滑动，并不是我们要的效果,为什么呢？原来animation默认以ease方式过渡，它会在每个关键帧之间插入补间动画，所以动画效果是连贯性的，知道原因就好办了，解决思路就是：12345@keyframes run&#123; 0%, 8%&#123; /*动作一*/ &#125; 9.2%, 17.2%&#123; /*动作二*/ &#125; ...&#125; step1：动作之间停留8帧，0%设置动作一，动作一结束在8%step2：动作之间过渡1.2帧，9.2%设置动作二，动作二结束在17.2% 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css3逐帧动画&lt;/title&gt; &lt;style&gt; @keyframes run&#123; 0%, 8%&#123; background-position: 0 0; &#125; 9.2%, 17.2%&#123; background-position: -140px 0; &#125; 18.4%, 26.4%&#123; background-position: -280px 0 ; &#125; 27.6%, 35.6%&#123; background-position: -420px 0 ; &#125; 36.8%, 44.8%&#123; background-position: -560px 0 ; &#125; 46%, 54%&#123; background-position: -700px 0 ; &#125; 55.2%, 63.2%&#123; background-position: -840px 0 ; &#125; 64.4%, 72.4%&#123; background-position: -980px 0 ; &#125; 73.6%, 81.6%&#123; background-position: -1120px 0 ; &#125; 82.8%, 90.8%&#123; background-position: -1400px 0 ; &#125; 92%, 100%&#123; background-position: -1540px 0 ; &#125; &#125; @-webkit-keyframes run&#123; 0%, 8%&#123; background-position: 0 0; &#125; 9.2%, 17.2%&#123; background-position: -140px 0; &#125; 18.4%, 26.4%&#123; background-position: -280px 0 ; &#125; 27.6%, 35.6%&#123; background-position: -420px 0 ; &#125; 36.8%, 44.8%&#123; background-position: -560px 0 ; &#125; 46%, 54%&#123; background-position: -700px 0 ; &#125; 55.2%, 63.2%&#123; background-position: -840px 0 ; &#125; 64.4%, 72.4%&#123; background-position: -980px 0 ; &#125; 73.6%, 81.6%&#123; background-position: -1120px 0 ; &#125; 82.8%, 90.8%&#123; background-position: -1400px 0 ; &#125; 92%, 100%&#123; background-position: -1540px 0 ; &#125; &#125; div&#123; width:140px; height:140px; background: url(http://images2015.cnblogs.com/blog/754767/201606/754767-20160601000042992-1734972084.png) ; animation:run 1s infinite; -webkit-animation:run 1s infinite; animation-fill-mode : backwards; -webkit-animation-fill-mode : backwards; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; steps方法还有另外一个实现方法，就是利用steps(),就是帧之间的阶跃动画，先贴个图 由上图可知:steps(1,start):动画一开始就跳到 100% 直到这一帧（不是整个周期）结束steps(1,end):保持 0% 的样式直到这一帧（不是整个周期）结束另外也可以直接设置 animation-timing-function:step-start/step-endstep-start效果等同于steps(1,start)，step-end效果等同于steps(1,end) 最终效果，因为录制的问题可能有点卡顿，有兴趣的同学可以直接复制代码去跑下： 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css3逐帧动画&lt;/title&gt; &lt;style&gt; @keyframes run&#123; 0%&#123; background-position: 0 0; &#125; 8.333%&#123; background-position: -140px 0; &#125; 16.666%&#123; background-position: -280px 0 ; &#125; 25.0%&#123; background-position: -420px 0 ; &#125; 33.333%&#123; background-position: -560px 0 ; &#125; 41.666%&#123; background-position: -700px 0 ; &#125; 50.0%&#123; background-position: -840px 0 ; &#125; 58.333%&#123; background-position: -980px 0 ; &#125; 66.666%&#123; background-position: -1120px 0 ; &#125; 75.0%&#123; background-position: -1260px 0 ; &#125; 83.333%&#123; background-position: -1400px 0 ; &#125; 91.666%&#123; background-position: -1540px 0 ; &#125; 100%&#123; background-position: 0 0 ; &#125; &#125; @-webkit-keyframes run&#123; 0%&#123; background-position: 0 0; &#125; 8.333%&#123; background-position: -140px 0; &#125; 16.666%&#123; background-position: -280px 0 ; &#125; 25.0%&#123; background-position: -420px 0 ; &#125; 33.333%&#123; background-position: -560px 0 ; &#125; 41.666%&#123; background-position: -700px 0 ; &#125; 50.0%&#123; background-position: -840px 0 ; &#125; 58.333%&#123; background-position: -980px 0 ; &#125; 66.666%&#123; background-position: -1120px 0 ; &#125; 75.0%&#123; background-position: -1260px 0 ; &#125; 83.333%&#123; background-position: -1400px 0 ; &#125; 91.666%&#123; background-position: -1540px 0 ; &#125; 100%&#123; background-position: 0 0 ; &#125; &#125; div&#123; width:140px; height:140px; background: url(http://images2015.cnblogs.com/blog/754767/201606/754767-20160601000042992-1734972084.png) ; animation:run 1s steps(1, start) infinite; -webkit-animation:run 1s steps(1, start) infinite; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
